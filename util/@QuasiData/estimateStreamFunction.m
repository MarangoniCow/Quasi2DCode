

function CoeffStruct = estimateStreamFunction(this, varargin)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % estimateStreamfunction(this)
    %
    % Calculates coefficients for the Quasi2D analytic streamfunction
    % -- the approximation for the 2D flow generated by a swimmer in
    % confinement.
    %
    % There are multiple different approximations for the
    % streamfunction. The approximation desired can be specified by
    % providing the 'approximationType' argument with the values 'A' or 'B'.
    %
    % The approximations are defined up to order 4, and the solve order
    % can be set by 'solveOrder'.
    %
    % When solving for the streamfunction, points close to the swimmer
    % may not satisfy the analytical expression. Consequently, we can
    % use the argument 'exclusionRadius' to define the exclusion radius
    % about the swimmer. This defaults to the colloid radius.
    %
    % INPUTS
    %   - approximationType         Function to be fitted, 'A' or 'B'
    %   - solveOrder                Maximum (up to 4) order of function
    %   - errorTol                  Error tolerance for fitting
    %   - exclusionRadius           Radius of excluded points around
    %                               the swimmer, from 0 to the channel
    %                               width.
    %   - includeDriftVelocity      Peroidic-boundary conditions in the
    %                               simulation produces a drift velocity
    %                               across the channel. We can include a
    %                               constant velocity term in the
    %                               approximation to account for this.
    %
    % OUTPUTS
    %   - CoeffStruct               Solution struct with the following:
    %                               ApproximationType
    %                               Coefficients
    %                               ExclusionRadius
    %                               Fminstats
    %                               Fminsum





    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                       PARSE INPUTS                              %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    p = inputParser;

    
    % Approximation type
    approximationDefault = 'B';
    approximationOptions = {'A', 'B'};
    approximationValidation = @(x) any(strcmp(x, approximationOptions));
    p.addOptional('approximationType', approximationDefault, approximationValidation);

    % Exclusion radius
    exclusionDefault = 2*this.colloidRadius;
    exclusionMax = floor(0.5*(this.VelData.systemSize(2) - this.colloidRadius));
    exclusionValidation = @(x) isnumeric(x) && x >= 0 && x <= exclusionMax;
    p.addOptional('exclusionRadius', exclusionDefault, exclusionValidation);

    % Solve order
    solveOrderDefault = 2;
    solveOrderMax = 10;
    solveOrderValidation = @(x) isPositiveIntegerValuedNumeric(x) && x > 0 && x <= solveOrderMax;
    p.addOptional('solveOrder', solveOrderDefault, solveOrderValidation);

    % Error tolerance
    errorTolDefault = 1e-4;
    errorTolValidation = @(x) isnumeric(x) && x > 0;
    p.addOptional('errorTol', errorTolDefault, errorTolValidation);

    % Drift velocity
    driftVelocityDefault = true;
    driftVelocityValidation  = @(x) islogical(x);
    p.addOptional('includeDriftVelocity', driftVelocityDefault, driftVelocityValidation);

    % Fminguess
    guessDefault = [];
    guessValidation = @(x) isnumeric(x);
    p.addOptional('fminGuess', guessDefault, guessValidation);

    parse(p, varargin{:})
    
    CoeffStruct = struct('ApproximationType', p.Results.approximationType, ...
                        'Coefficients', [], 'Fminstats', [], 'Fminsum', [], ...
                        'ExclusionRadius', p.Results.exclusionRadius);


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                   LOCALLY-SCOPED VARIABLES                      %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    
    % Fetch coordinate data
    X = this.VelData.X(:);
    Y = this.VelData.Y(:);
    R = this.VelData.R(:);
    Th = this.VelData.Th(:);
    
    
    % Fetch velocity data
    Vr = this.VelData.velocityPlanePolar(:, :, 1);
    Vt = this.VelData.velocityPlanePolar(:, :, 2);
    Vr = Vr(:);
    Vt = Vt(:);
    
    % Fetch parameters
    x0 = this.VelData.x0;
    y0 = this.VelData.y0;
    
    
    % Generate list of points to exclude
    a = this.VelData.colloid_a;
    U = this.VelData.colloidVel(:, this.VelData.timeStep);
    U = sqrt(dot(U, U));
    

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                   GENERATE EXCLUSION RADIUS                     %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    [Xc, Yc] = generateRadialXYPoints(x0, y0, a + p.Results.exclusionRadius);
    
    % Generate idx list of points
    idxList = [];

    % For each element in the excluded list of points...
    for i = 1:length(Xc)
        
        % ...if there's a corresponding matching point in the mesh, it
        % will need to be removed.
        for j = 1:length(X)
    
            if(Xc(i) == X(j) && Yc(i) == Y(j))
                idxList = [idxList, j];
                break;
            end
        end
    end
    
    % Delete colloidal points that shouldn't be use in parameter
    % matching (colloid radius + some buffer)
    X(idxList) = [];
    Y(idxList) = [];
    Vr(idxList) = [];
    Vt(idxList) = [];
    R(idxList) = [];
    Th(idxList) = [];
    N = length(X);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                       SET-UP FMINSEARCH                         %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Solve order
    solveOrder = p.Results.solveOrder;
    
    guess = p.Results.fminGuess;
    % fminGuess
    if isempty(guess)

        % Switch between orders
        switch p.Results.approximationType
            case 'A'
                guess = ones(1, solveOrder);
            case 'B'
                for i = 1:solveOrder
                    guess = [guess, 10^i];
                end
        end
    
        if p.Results.includeDriftVelocity
            guess = [guess, 0.1];
        end
    else

        % Validate that guess is the correct length
        if p.Results.includeDriftVelocity
            L = p.Results.solveOrder + 1;
        else
            L = p.Results.solveOrder;
        end

        if L ~= length(guess)
            error('FminGuess is incorrect length');
        end
    end
    

    % fminsearch options
    options = optimset('MaxFunEvals', 200*length(guess), 'MaxIter', 200*length(guess), 'TolFun', p.Results.errorTol);
    
    % Run fminsearch
    switch p.Results.approximationType
        case 'A'
            [this.CoeffA, CoeffStruct.Fminsum, ~, this.statsA]  = fminsearch(@Q2D_Approximation_A, guess, options);
            
            if ~p.Results.includeDriftVelocity
                this.CoeffA = [this.CoeffA, 0];
            end
            
            CoeffStruct.Coefficients = this.CoeffA;
            CoeffStruct.Fminstats = this.statsA;

            
        case 'B'
            [this.CoeffB, CoeffStruct.Fminsum, ~, this.statsB] = fminsearch(@Q2D_Approximation_B, guess, options);

            if ~p.Results.includeDriftVelocity
                this.CoeffB = [this.CoeffB, 0];
            end

            CoeffStruct.Coefficients = this.CoeffB;
            CoeffStruct.Fminstats = this.statsB;

            
    end

    


    
    
    
    %%%%%%%%%%%%%%%%%% ANALYTICALLY DEFINED STREAM FUNCTIONS %%%%%%%%%%%%%%%%%%
        
    function f = Q2D_Approximation_A(B)
        % INPUT PARAMETERS
        %   b1, b2, c1, c2          - Unknown constants to be solved for
        %   x0, y0                  - Swimmer/colloid center
        %   lambda                  - 'Screening length' parameter, should be set
        %                               to sqrt(h^2/2)
        %   x, y                    - Cartesian coordinates to be solved at
        
        % Local helper functions
        switch length(B)
            case 2
                B1 = B(1);
                B2 = 0;
                B3 = 0;
                B4 = 0;
                C1 = B(2);
                C2 = 0;
                C3 = 0;
                C4 = 0;
            case 4
                B1 = B(1);
                B2 = B(2);
                B3 = 0;
                B4 = 0;
                C1 = B(3);
                C2 = B(4);
                C3 = 0;
                C4 = 0;
            case 6
                B1 = B(1);
                B2 = B(2);
                B3 = B(3);
                B4 = 0;
                C1 = B(4);
                C2 = B(5);
                C3 = B(6);
                C4 = 0;
            case 8
                B1 = B(1);
                B2 = B(2);
                B3 = B(3);
                B4 = B(4);
                C1 = B(5);
                C2 = B(6);
                C3 = B(7);
                C4 = B(8);

            otherwise
                error('Undetermined number of coefficients')
        end
        

        lambda = this.lambda;
        
        
        f = 0;

        for idx = 1:N
        
            r = R(idx);
            theta = Th(idx);

            

            % Define besselk'_i(r/lambda)
            BKD1 = -1./lambda.*(besselk(0, r./lambda) + lambda./r.*besselk(1, r./lambda));
            BKD2 = -1./lambda.*(besselk(1, r./lambda) + 2.*lambda./r.*besselk(2, r./lambda));
            BKD3 = -1./lambda.*(besselk(2, r./lambda) + 3.*lambda./r.*besselk(3, r./lambda));
            BKD4 = -1./lambda.*(besselk(3, r./lambda) + 4.*lambda./r.*besselk(4, r./lambda));
        
            % Define radial component
            ur =    1*B1.*r.^-2.*cos(theta) + ...
                    2*B2.*r.^-3.*cos(2*theta) + ...
                    3*B3.*r.^-4.*cos(3*theta) + ...
                    4*B4.*r.^-5.*cos(4*theta) + ...
                    1*C1./r.*cos(1*theta).*besselk(1, r./this.lambda) + ...
                    2*C2./r.*cos(2*theta).*besselk(2, r./this.lambda) + ...
                    3*C3./r.*cos(3*theta).*besselk(3, r./this.lambda) + ...
                    4*C4./r.*cos(4*theta).*besselk(4, r./this.lambda);
            
            % Define angular component
            ut =    1*B1.*r.^-2.*sin(1*theta) + ...
                    2*B2.*r.^-3.*sin(2*theta) + ... 
                    3*B3.*r.^-4.*sin(3*theta) + ... 
                    4*B4.*r.^-5.*sin(4*theta) + ... 
                    -C1.*sin(1*theta)./lambda.*BKD1 + ...
                    -C2.*sin(2*theta)./lambda.*BKD2 + ...
                    -C3.*sin(3*theta)./lambda.*BKD3 + ...
                    -C4.*sin(4*theta)./lambda.*BKD4;
            
            % Summation
            f = f + sqrt((Vr(idx) - ur).^2 + (Vt(idx) - ut).^2);
            
        end
        f = f./N;
    end

    function fsum = Q2D_Approximation_B(B)
        % INPUT PARAMETERS
        %   b1, b2, c1, c2          - Unknown constants to be solved for
        %   x0, y0                  - Swimmer/colloid center
        %   lambda                  - 'Screening length' parameter, should be set
        %                               to sqrt(h^2/2)
        %   x, y                    - Cartesian coordinates to be solved at


        % Sum variable
        fsum = 0;

        % Screening length
        lambda = this.lambda;

        % Complete sum over all lattice points         
        for idx = 1:N

            % Fetch radial and angular variables            
            r = R(idx);
            theta = Th(idx);

            % Define ur and ut: add simulation drift velocity if requested
            if p.Results.includeDriftVelocity
                ur = B(end).*cos(theta);
                ut = -B(end).*sin(theta);
            else
                ur = 0;
                ut = 0;
            end


            
            % Run over solve order
            for n = 1:solveOrder

                % Shorthand notations
                kappa   = besselk(n, a./lambda);
                BK      = besselk(n, r./lambda)./kappa;
                BKD     = -1./lambda.*(besselk(n - 1, r./lambda) + n*lambda./r.*besselk(n, r./lambda))./kappa;

                % Add U terms
                if n == 1
                    ur = ur + U.*a.*cos(theta)./r.*BK;
                    ut = ut - U.*a.*sin(theta).*BKD;
                end
                
                % Radial and angular velocities
                ur = ur + n*B(n).*cos(n.*theta)./r.*(r.^(-n) - a.^-(n).*BK);
                ut = ut + B(n).*sin(n*theta).*(n.*r.^(-n -1) + a.^(-n).*BKD);
                
               
            end
            
           
            % Take fum over difference between analytical and
            % simulation velocities                
            fsum = fsum + (Vr(idx) - ur).^2 + (Vt(idx) - ut).^2;
        end

        % Normalise to the number of lattice points N
        fsum = fsum./N;
    end

end