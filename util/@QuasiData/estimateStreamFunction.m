

function CoeffStruct = estimateStreamFunction(this, varargin)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    % estimateStreamfunction(this)
    %
    % Calculates coefficients for the Quasi2D analytic streamfunction
    % -- the approximation for the 2D flow generated by a swimmer in
    % confinement.
    %
    % There are multiple different approximations for the
    % streamfunction. The approximation desired can be specified by
    % providing the 'approximationType' argument with the values 'A' or 'B'.
    %
    % The approximations are defined up to order 4, and the solve order
    % can be set by 'solveOrder'.
    %
    % When solving for the streamfunction, points close to the swimmer
    % may not satisfy the analytical expression. Consequently, we can
    % use the argument 'exclusionRadius' to define the exclusion radius
    % about the swimmer. This defaults to the colloid radius.
    %
    % INPUTS
    %   - approximationType         Function to be fitted, 'A' or 'B'
    %   - solveOrder                Maximum (up to 4) order of function
    %   - errorTol                  Error tolerance for fitting
    %   - exclusionRadius           Radius of excluded points around
    %                               the swimmer, from 0 to the channel
    %                               width.
    %   - includeDriftVelocity      Peroidic-boundary conditions in the
    %                               simulation produces a drift velocity
    %                               across the channel. We can include a
    %                               constant velocity term in the
    %                               approximation to account for this.
    %
    % OUTPUTS
    %   - CoeffStruct               Solution struct with the following:
    %                               ApproximationType
    %                               Coefficients
    %                               ExclusionRadius
    %                               Fminstats
    %                               Fminsum





    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                       PARSE INPUTS                              %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    p = inputParser;

    
    % Approximation type
    approximationDefault = 'B';
    approximationOptions = {'A', 'B'};
    approximationValidation = @(x) any(strcmp(x, approximationOptions));
    p.addOptional('approximationType', approximationDefault, approximationValidation);

    % Exclusion radius
    exclusionDefault = 2*this.VelData.colloidRadius;
    exclusionMax = floor(0.5*(this.VelData.systemSize(2) - this.VelData.colloidRadius));
    exclusionValidation = @(x) isnumeric(x) && x >= 0 && x <= exclusionMax;
    p.addOptional('exclusionRadius', exclusionDefault, exclusionValidation);

    % Solve order
    solveOrderDefault = 2;
    solveOrderMax = 10;
    solveOrderValidation = @(x) isPositiveIntegerValuedNumeric(x) && x > 0 && x <= solveOrderMax;
    p.addOptional('solveOrder', solveOrderDefault, solveOrderValidation);

    % Error tolerance
    errorTolDefault = 1e-4;
    errorTolValidation = @(x) isnumeric(x) && x > 0;
    p.addOptional('errorTol', errorTolDefault, errorTolValidation);

    % Drift velocity
    driftVelocityDefault = true;
    driftVelocityValidation  = @(x) islogical(x);
    p.addOptional('includeDriftVelocity', driftVelocityDefault, driftVelocityValidation);

    % Fminguess
    guessDefault = [];
    guessValidation = @(x) isnumeric(x);
    p.addOptional('fminGuess', guessDefault, guessValidation);

    parse(p, varargin{:})
    
    CoeffStruct = struct('ApproximationType', p.Results.approximationType, ...
                        'Coefficients', [], 'Fminstats', [], 'Fminsum', [], ...
                        'ExclusionRadius', p.Results.exclusionRadius);


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                   LOCALLY-SCOPED VARIABLES                      %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    
    % Fetch coordinate data
    X = this.VelData.X(:);
    Y = this.VelData.Y(:);
    R = this.VelData.R(:);
    Th = this.VelData.Th(:);
    
    
    % Fetch velocity data
    Vx = this.VelData.velocityPlaneCartesian(:, :, 1);
    Vy = this.VelData.velocityPlaneCartesian(:, :, 2);
    Vx = Vx(:);
    Vy = Vy(:);
    
    % Fetch parameters
    x0 = this.VelData.x0;
    y0 = this.VelData.y0;
    
    
    % Generate list of points to exclude
    a = this.VelData.colloidRadius;
    U = this.VelData.colloidVel(:, this.VelData.timeStep);

    

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                   GENERATE EXCLUSION RADIUS                     %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    [Xc, Yc] = generateRadialXYPoints(x0, y0, a + p.Results.exclusionRadius);
    
    % Generate idx list of points
    idxList = [];

    % For each element in the excluded list of points...
    for i = 1:length(Xc)
        
        % ...if there's a corresponding matching point in the mesh, it
        % will need to be removed.
        for j = 1:length(X)
    
            if(Xc(i) == X(j) && Yc(i) == Y(j))
                idxList = [idxList, j];
                break;
            end
        end
    end
    
    % Delete colloidal points that shouldn't be use in parameter
    % matching (colloid radius + some buffer)
    X(idxList) = [];
    Y(idxList) = [];
    Vx(idxList) = [];
    Vy(idxList) = [];
    R(idxList) = [];
    Th(idxList) = [];
    N = length(X);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                       SET-UP REFLECTIONS                        %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    L = this.VelData.systemSize(1);
    W = this.VelData.systemSize(2);

    % REFLECTION NUMBERING:
    %   Apply reflections in all 8 lattice points around the channel, numbering each transformation from 1 through 8
    %   where we start with the reflectionin the +ve y-plane.
    
    Rr = cell(1, 8);
    Thr = cell(1, 8);

    [Thr{1}, Rr{1}] = this.colloidCoordinateTransformation(x0, y0 + W);
    [Thr{2}, Rr{2}] = this.colloidCoordinateTransformation(x0 + L, y0 + W);
    [Thr{3}, Rr{3}] = this.colloidCoordinateTransformation(x0 + L, y0);
    [Thr{4}, Rr{4}] = this.colloidCoordinateTransformation(x0 + L, y0 - W);
    [Thr{5}, Rr{5}] = this.colloidCoordinateTransformation(x0 , y0 - W);
    [Thr{6}, Rr{6}] = this.colloidCoordinateTransformation(x0 - L, y0 - W);
    [Thr{7}, Rr{7}] = this.colloidCoordinateTransformation(x0 - L, y0);
    [Thr{8}, Rr{8}] = this.colloidCoordinateTransformation(x0 - L, y0 + W);
    

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                       SET-UP FMINSEARCH                         %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Solve order
    solveOrder = p.Results.solveOrder;
    
    guess = p.Results.fminGuess;
    % fminGuess
    if isempty(guess)

        % Switch between orders
        switch p.Results.approximationType
            case 'A'
                guess = ones(1, solveOrder);
            case 'B'
                for i = 1:solveOrder
                    guess = [guess, 10^i];
                end
        end
    
        if p.Results.includeDriftVelocity
            guess = [guess, 0.1];
        end
    else

        % Validate that guess is the correct length
        if p.Results.includeDriftVelocity
            L = p.Results.solveOrder + 1;
        else
            L = p.Results.solveOrder;
        end

        if L ~= length(guess)
            error('FminGuess is incorrect length');
        end
    end
    

    % fminsearch options
    options = optimset('MaxFunEvals', 200*length(guess), 'MaxIter', 200*length(guess), 'TolFun', p.Results.errorTol);
    
    % Run fminsearch
    [this.Coeff, CoeffStruct.Fminsum, ~, this.Stats] = fminsearch(@ApproximateQuasiFlow, guess, options);
    
    % Default behaviour of graphing functions is to assume the last coefficient corresponds to the drift velocity. Set
    % to zero if it hasn't been included in the approximation.
    if ~p.Results.includeDriftVelocity
        this.Coeff = [this.Coeff, 0];
    end

    CoeffStruct.Coefficients = this.Coeff;
    CoeffStruct.Fminstats = this.Stats;
    this.Fminsum = CoeffStruct.Fminsum;


    
    function fsum = ApproximateQuasiFlow(B)
        % INPUT PARAMETERS
        %   b1, b2, c1, c2          - Unknown constants to be solved for
        %   x0, y0                  - Swimmer/colloid center
        %   lambda                  - 'Screening length' parameter, should be set
        %                               to sqrt(h^2/2)
        %   x, y                    - Cartesian coordinates to be solved at

        % Sum variable
        fsum = zeros(1, N);

        % Complete sum over all lattice points         
        for idx = 1:N

            % Fetch quasi-2D flow field
            [ux, uy] = this.quasi2DVelocity(B, R(idx), Th(idx));
            
            % Add reflections to computer flow fields
            for j = 1:8
                [uxr, uyr] = this.quasi2DVelocity(B, Rr{j}(idx), Thr{j}(idx));
                ux = ux + uxr;
                uy = uy + uyr;
            end
                            
            % Take fminsum over non-dimensionalised difference between simulation and analytical quantities
            factor = norm(U)*a/R(idx);
            fsum(idx) = sqrt((Vx(idx) - ux).^2 + (Vy(idx) - uy).^2)./factor;
        end

        % Normalise to the number of lattice points N
        fsum = sum(fsum)./N;

    end
end